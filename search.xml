<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>DEBUG</title>
      <link href="/post/9bf18517.html"/>
      <url>/post/9bf18517.html</url>
      
        <content type="html"><![CDATA[<h1 id="Mac下-bash-profile和-zshrc区别"><a href="#Mac下-bash-profile和-zshrc区别" class="headerlink" title="Mac下.bash_profile和.zshrc区别"></a>Mac下.bash_profile和.zshrc区别</h1><p>.bash_profile 中修改环境变量只对当前窗口有效，而且需要 source ~&#x2F;.bash_profile才能使用<br>.zshrc 则相当于 windows 的开机启动的环境变量，主要保存个人的一些个性化设置，比如命令别名、路径等<br>你也可以在 .zshrc 文件中加一行 source .bash_profile 解决需要 source 才能使用的问题</p><ul><li>在Mac OS安装llvm出现的问题，通过修改.zshrc文件仍然无法link到llvm，需要source才行<br><img src="/../img/llvm_bug.jpg"><br>使用zsh作为默认的shell，关机重启后，配置的环境变量就不生效了，必须运行source ~&#x2F;.bash_profile才能生效，通过在.zshrc文件中添加source .bash_profile,使以后配置的环境变量永久生效。<br><a href="https://www.jianshu.com/p/e4cbcd764783">https://www.jianshu.com/p/e4cbcd764783</a></li></ul><h1 id="clang找不到标准库头文件错误"><a href="#clang找不到标准库头文件错误" class="headerlink" title="clang找不到标准库头文件错误"></a>clang找不到标准库头文件错误</h1>]]></content>
      
      
      
        <tags>
            
            <tag> DEBUG </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Computer_Architecture_A_Quantitive_Approach</title>
      <link href="/post/a2cb2629.html"/>
      <url>/post/a2cb2629.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考资料:   </p><ul><li>《Computer Architecture _ a quantitive approach the sixth》</li><li>《计算机组成原理 —— 软硬件接口》     </li><li>高体ppt  </li><li>相关Blog和资料</li><li>第六版将指令集从MIPS切换到了RISC-V，作者认为RISC-V这个现代、模块化、开放的指令集可能在信息技术行业成为一个意义非凡的力量，在计算机架构领域的重要性可能会像Linux在操作系统领域一样，同时新增Chapter 7，引入domain-specific架构的介绍，介绍了几个具体的工业例子。</li></ul></blockquote><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="非知识性内容"><a href="#非知识性内容" class="headerlink" title="非知识性内容"></a>非知识性内容</h2><p>能力的提升包括以下几个方面：</p><ul><li>阅读能力：mostly books, papers and articles，总结出主旨并产生自己的观点，自主学习（阅读书籍之前首先要对阅读策略进行研究）</li><li>应用能力：网络、工具、编程、数学等，学习如何设计、分析、验证并修正自己的观点，工程能力的培养</li><li>合作和沟通能力: Formal speaking, listening, meeting and rules,社交和管理能力</li></ul><p>研究生阶段课程和本科的区别：</p><ul><li>How to run? -&gt; How to run faster?</li></ul><p>本科：</p><ul><li>Instruction set architecture ISA</li><li>Basic pipeline &amp; concepts</li></ul><p>研究生：</p><ul><li>Introduction Level Parallelism (ILP) </li><li>Thread-Level Parallelism (TLP)</li><li>Request-Level Parallelism (RLP)</li><li>Data-Level Parallelism (DLP)</li></ul><h2 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h2><ol><li>应用的变化<br>数值型科学计算-&gt;商业娱乐；增长的内存需求；单线程-&gt;多线程；单机-&gt;网络；character-oriented-&gt;multimedia:video, audio, graphics</li><li>计算机分类（一般一种事物在诞生之初只有一种，随着同环境的不断交互，逐渐分化，后代替换或弥补前面几代，逐渐形成类别）<br>1960s,mainframe<br>1970s, minicomputer &amp; supercomputer<br>1980s, Microprocessor &amp; Desktop(workstations &amp; PC) &amp; servers<br>1990s, Internet &amp; PDA, games, set-top boxes<br>2000, Cell phone … embedded computer<br>Now: Edge Computer</li><li>计算机技术发展：半导体技术的提升；计算机体系结构的发展，几个节点还是要了解一下<br>1970s:Market; Enabled by HLL compilers:asm,…,C; Vendor-independent OS:UNIX<br>1980s:Lead to RISC architectures: Parallel in a chip:ILP; Cheaper high-performance memory:cache<br>1990s: CISC to RISC like<br>2000s: Lightweight computers</li></ol><h2 id="知识性内容"><a href="#知识性内容" class="headerlink" title="知识性内容"></a>知识性内容</h2><ol><li><p>理解计算机体系结构<br>计算机体系结构实际上是针对底层物理实现的抽象层设计，允许上层应用高效的使用底层基础设施。</p></li><li><p>现代系统的抽象层次结构<br><img src="/../img/layers.jpg" alt="抽象层次结构"><br>体系结构限定的范围也在变化，更加细化</p></li><li><p>Computer Architecture:An Integrated Approach<br>根据目标机器确定具体的需求；在已有的限制下(cost, power and availability)最大化机器性能<br>三个角度：ISA, 微体系结构(Origanization), 硬件(Implementation)<br>计算机体系结构不只是transistors, individual instructions or particular implementations</p></li><li><p>技术趋势<br>集成电路技术：晶体管密度：35%&#x2F;year；Die size：10%-20%&#x2F;year；Integration overall:40%-50%&#x2F;year<br>DRAM容量：25%-40%&#x2F;year(slowing 内存墙，内存容量的增长速度远远不能跟上CPU内核增长速度)<br>Flash容量：50-60%&#x2F;year; 15-20x cheaper&#x2F;bit than DRAM<br>磁盘技术：40%&#x2F;year 比Flash便宜15-25x，比DRAM便宜300-500x<br>网络：延迟，带宽，无线 </p></li><li><p>Moore’s Law<br><img src="/../img/moore.jpg"></p></li><li><p>Intel研发重心转移<br>2004年开始Intel将重心从研发高性能单处理器转移到多处理器芯片上，不再单独依赖ILP指令级并行，而将更多使用DLP数据级并行，TLP线程级并行。ILP是软件程序不感知的并行，而DLP、TLP、RLP都需要程序显式感知，这也增大了软件编程的难度。</p></li><li><p>Dennard缩放定律<br>随着晶体管尺寸越来越小，功耗密度保持不变，即单位面积的功耗保持不变。</p></li><li><p>Amdahl定律<br>系统中某一部件因为采用更快的实现后，整个系统性能的提高与该部分的使用频率或者在总运行时间中所占比例有关。</p></li></ol><h1 id="Chapter-One"><a href="#Chapter-One" class="headerlink" title="Chapter One"></a>Chapter One</h1><blockquote><p>介绍了一些公式，这些公式用于计算功耗，静态功率，动态功率，集成电路成本，可靠性和可用性等。这些公式被用于随后章节的量化分析设计和性能测量。ISA在Appendix A，因为作者认为它扮演的角色已经不像1990年那么重要了。</p><ul><li>Classes of Computers </li><li>体系结构的定义</li><li>技术趋势</li><li>集成电路中的功率和能耗趋势</li><li>成本趋势</li><li>可靠性</li><li>性能的测量、报告和汇总</li><li>计算机设计的量化原理</li><li>Put it all together: 性能、价格和功耗</li><li>Fallacies and Pitfalls</li></ul></blockquote><h2 id="计算机的分类"><a href="#计算机的分类" class="headerlink" title="计算机的分类"></a>计算机的分类</h2><ol><li>PMD<br>限制较多：成本、能效；应用程序的响应性能和可预测性（实时性能）；存储器占用降至最小（存储器可能在系统成本中占有很大比例，存储器优化很重要，由于应用程序已经决定了数据规模，所以重视存储器容量其实就是要重视代码规模）；电池容量以及散热</li><li>PC</li><li>Server<br>可用性；可扩展性；高吞吐（尽管对单个请求的相应速度很重要，但是总体效率和成本效益——由单位时间内能够处理的请求数决定）才是大多数服务器的关键度量）</li><li>集群&#x2F;仓库级计算机<br>集群：一组计算机通过局域网连接在一起，每个节点运行自己的操作系统，节点之间使用网络协议进行通信。最大规模的集群称为WSC仓库级计算机。<br>WSC与服务器的区别：廉价组建构建，依靠软件层捕获和隔离在这一级别计算时发生的问题<br>WSC与超算的区别：超算强调浮点性能，处理通信密集的批程序，需要高速内部网络；WSC重视互动应用程序、大规模存储、可靠性和较高Internet带宽<br>WSC可扩展性和服务器可扩展性区别：WSC可扩展性通过连接计算机的局域网实现；服务器通过集成计算机硬件实现</li><li>嵌入式计算机（6th无）<br>达到最低标准的性能需要（能否运行第三方软件作为区分嵌入式和非嵌入式的分界线）；嵌入式计算领域数据不够充足</li></ol><h3 id="并行度和并行体系结构分类"><a href="#并行度和并行体系结构分类" class="headerlink" title="并行度和并行体系结构分类"></a>并行度和并行体系结构分类</h3><ol><li>应用程序中主要有以下两种并行<br>数据级并行DLP<br>任务级并行TLP</li><li>计算机硬件以如下4种方式开发以上两种应用并行    <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">a 指令级并行 instruction-level</span><br><span class="line">  在编译器的帮助下使用流水线等思想适度开发DLP，利用推理执行speculative execution的思想以中等水平开发数据级并行</span><br><span class="line">b 向量体系结构和图形处理器GPU vector architecture, graphic processor units</span><br><span class="line">  单条指令并行应用于一个数据集以开发DLP</span><br><span class="line">c 线程级并行 thread-level</span><br><span class="line">  在紧耦合硬件模型中开发DLP或TLP，这种模型允许在并行线程之间交互</span><br><span class="line">d 请求级并行 request-level</span><br><span class="line">  在程序员或os指定的大量去耦合任务之间开发并行</span><br></pre></td></tr></table></figure></li><li>Michael Flynn分类<br>SISD；SIMD；MISD；MIMD<br>SIMD每个处理器有自己的数据存储器，但是<mark>只有一个指令存储器和控制处理器</mark></li></ol><h2 id="Defining-Computer-Architecture"><a href="#Defining-Computer-Architecture" class="headerlink" title="Defining Computer Architecture"></a>Defining Computer Architecture</h2><blockquote><p>考虑对于要完成的任务来说，哪些属性是最重要的。任务包括：指令集设计、功能组织、逻辑设计、实现方式；实现方式可能包括：集成电路设计、包装、电池和冷却。  </p></blockquote><h3 id="ISA-分类"><a href="#ISA-分类" class="headerlink" title="ISA 分类"></a>ISA 分类</h3><ol><li>register-memory ISAs, eg:80x86</li><li><font color=#f0808> load-store ISAs</font>, eg:ARMv8, RISC-V (access memory only with load or store instructions, All ISAs announced since 1985 are load-store)</li></ol><h3 id="Memory-addressing-存储器寻址"><a href="#Memory-addressing-存储器寻址" class="headerlink" title="Memory addressing 存储器寻址"></a>Memory addressing 存储器寻址</h3><p>Almost all 使用<mark>byte addressing</mark> 访问存储器操作数。有些体系结构要求操作数对齐（ARMv7），x86不需要，但是如果操作数对齐，访问的速度会更快。一个对象的字节地址Address mod size &#x3D; 0,则对该地址的访问是对齐的。</p><h3 id="Addressing-modes-寻址模式"><a href="#Addressing-modes-寻址模式" class="headerlink" title="Addressing modes 寻址模式"></a>Addressing modes 寻址模式</h3><p>register + constant operands + memory object<br>RISC-V: Register,Immediate(for constants),Displacement位移量<br>x86: Register,Immediate(for constants),Displacement位移量 + no register(absolute), two registers(based indexed with displacement), two registers where one register is multiplied by the size of the operand in bytes (based with scaled index and displacement).寄存器间接寻址+基址寻址+变址寻址+PC相对寻址+自动递增&#x2F;递减寻址</p><h3 id="Types-and-sizes-of-operands-操作数类型和大小"><a href="#Types-and-sizes-of-operands-操作数类型和大小" class="headerlink" title="Types and sizes of operands 操作数类型和大小"></a>Types and sizes of operands 操作数类型和大小</h3><h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><p>数据传输；算术逻辑；控制指令；浮点指令</p><h3 id="控制流指令"><a href="#控制流指令" class="headerlink" title="控制流指令"></a>控制流指令</h3><p>conditional branches 条件转移；<br>unconditional jumps 无条件跳转；<br>procedure calls and returns 过程调用和返回；<br>以上三种都使用相对PC的寻址方式，其中的分支地址由一个地址字段指定，该地址被加到PC。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># branches</span></span><br><span class="line"><span class="comment"># RISC-V </span></span><br><span class="line"><span class="built_in">test</span> contents of registers</span><br><span class="line"><span class="comment"># x86 &amp; ARMv8</span></span><br><span class="line"><span class="built_in">test</span> condition code bits <span class="comment"># 执行算术/逻辑运算时置位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># procedure calls and returns</span></span><br><span class="line"><span class="comment"># ARMv8 &amp; RSIC-V</span></span><br><span class="line"><span class="built_in">return</span> register</span><br><span class="line"><span class="comment"># x86</span></span><br><span class="line"><span class="built_in">return</span> stack <span class="keyword">in</span> memory</span><br></pre></td></tr></table></figure><h3 id="ISA编码"><a href="#ISA编码" class="headerlink" title="ISA编码"></a>ISA编码</h3><p>fixed length<br>variable length<br><img src="/../img/RISC_V.jpg"></p><h3 id="真实的体系结构"><a href="#真实的体系结构" class="headerlink" title="真实的体系结构"></a>真实的体系结构</h3><p>计算机的实现包括两个方面：组成和硬件。<br>组成&#x3D;微体系结构；比如存储器系统、存储器互联、设计内部处理器或CPU等<br>单个微处理器上开始采用多个处理器，故用核心来称呼处理器<br>硬件是一个计算机的具体实现，包括计算机的详尽逻辑设计和封装技术；同一系列的计算机通常具有相同的指令集体系结构和几乎相同的组成，但是在具体的硬件实现方面有所不同。<br>本书的计算机体系结构包括ISA、组成、硬件。</p><blockquote><p>架构师需要考虑的内容<br>架构师设计的计算机必须满足功能需求，并达到价格、功耗、性能和可用性指标。通常架构师还必须判断有什么样的功能要求，其中哪一项可能是主要任务。需求可能是市场驱动的特定功能。应用软件决定了计算机的使用方式，从而经常会推动特定功能需求的选择。如果存在大量为一特定指令集体系结构设计的软件了，架构师可能会决定：新计算机应当实现这种已有的指令集。如果某类应用程序拥有庞大的市场，那可能会鼓励设计人员整合一些需求，使计算机在这一市场上具有更强的竞争力。【抓住重点+灵活应变+整合需求提高弹性】<br>架构师还必须了解技术和计算机应用这两方面的重要趋势，因为这些趋势不仅会影响未来的成本，还会影响到体系结构的寿命。</p></blockquote><h2 id="技术趋势"><a href="#技术趋势" class="headerlink" title="技术趋势"></a>技术趋势</h2><ol><li>集成电路逻辑技术</li><li>半导体DRAM</li><li>半导体Flash</li><li>磁盘技术</li><li>网络技术：取决于交换机性能和传输系统的性能<br>设计人员必须为应对关键技术的变化做好准备。设计人员在设计时经常要考虑到下一代技术，因为当一代产品开始大量交付时，下一代技术可能是最具成本效益的，或者可能拥有性能优势。尽管技术进步是连续性的，但是只有当技术积累到一定程度，为新功能的出现做好准备时，才会产生跳跃性的、不连续的影响。20世纪80年代后期，一级缓存可以出现在一个芯片上。通过消除处理器内部以及处理器与缓存之间的芯片交叉，使成本效率和能耗效率大幅提高成为可能。在技术发展到一定程度之前，这种设计无法实现。设计决策也受到技术门槛的影响。</li></ol><h3 id="Performance-Trends-Bandwidth-over-Latency"><a href="#Performance-Trends-Bandwidth-over-Latency" class="headerlink" title="Performance Trends: Bandwidth over Latency"></a>Performance Trends: Bandwidth over Latency</h3><p>性能是区分微处理器和网络的主要指标，所以容量提高的最多</p><h2 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h2><h3 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h3><blockquote><p>一种存储二进制数据的容器；object size(cells&#x2F;bits_8bits) + memory size + address &#x3D; specify a memory </p></blockquote><ol><li>Accessing Mode: Bytes(8 bits);Half word(16bits);Words(32bits);Double words(64bits)</li><li>大端寻址和小端寻址: 按Byte分</li><li>字节对齐Byte aligned</li></ol><h3 id="Registers"><a href="#Registers" class="headerlink" title="Registers"></a>Registers</h3><blockquote><p>CPU内部的一种存储形式；3种类型register file: acc, stack, register </p></blockquote><h2 id="Operands"><a href="#Operands" class="headerlink" title="Operands"></a>Operands</h2><h2 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Computer Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IC验证实习入坑准备</title>
      <link href="/post/95a38ed7.html"/>
      <url>/post/95a38ed7.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>摸鱼必备（一）</title>
      <link href="/post/99866e21.html"/>
      <url>/post/99866e21.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单介绍RSS(Really Simple Syndication，简易信息聚合)，是一种描述和同步网站内容的格式。可以定制个性化信息推送服务，减少海量信息下浏览负担。不同产品不同域名，没有一个集合所有文章的门户。</p></blockquote><ul><li>专业记者们往往有自己的beat，在某一任务或话题上有经年累月的知识积累才能产生出有深度和广度的报道，才能注意到不被一般媒体注意到的细节。</li><li>一般搜索公司名称+产品名+Blog就可以查到相关内容，eg:Intel Sapphire rapids CPU Blog</li><li>还要关注一些公司的newsroom,eg:intel&#x2F;newsroom, sumsung&#x2F;newsroom …</li><li>RSS阅读器：<a href="https://netnewswire.com/help/mac/6.1/en/getting-started">netnewswire</a></li><li>添加RSS，一般直接将网站的url拷贝即可，有的时候在后面加上rss, rss.html, rss.xml也行，实在没有可以自动生成，很多自动生成RSS的工具，可参考：<a href="https://zhuanlan.zhihu.com/p/55026716">如何用RSS订阅？</a></li></ul><figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">NetNewsWire Shortcuts</span><br><span class="line"><span class="section">### Everywhere shortcuts</span></span><br><span class="line">Funtions                                    Shortcuts</span><br><span class="line">Scroll or go to next unread                space</span><br><span class="line">Go to next unread                        n or +</span><br><span class="line">Toggle read status                        r or u</span><br><span class="line">Mark all as read                        k</span><br><span class="line">Mark older articles as read                o</span><br><span class="line">Mark all as read, go to next unread        l</span><br><span class="line">Mark as unread, go to next unread        m</span><br><span class="line">Toggle starred status                    s </span><br><span class="line">Open in browser                            b or ⏎ or Enter</span><br><span class="line">Previous subscription                    a</span><br><span class="line">Next subscription                        z</span><br><span class="line"><span class="section">### Feed list</span></span><br><span class="line">Collapse                                , or ⌥ ←</span><br><span class="line">Expand                                    . or ⌥ →</span><br><span class="line">Collapse All (except for group items)    ; or ⌥⌘ ←</span><br><span class="line">Expad All                                &#x27; or ⌥⌘ →</span><br><span class="line">Move focus to headlines                    →</span><br><span class="line"><span class="section">### Timeline</span></span><br><span class="line">Move focus to subscriptions                ←</span><br><span class="line">Move focus to detail                    →</span><br><span class="line"><span class="section">### Article view</span></span><br><span class="line">Move focus to article list timeline        ←</span><br></pre></td></tr></table></figure><h1 id="存储和HPC相关资讯"><a href="#存储和HPC相关资讯" class="headerlink" title="存储和HPC相关资讯"></a>存储和HPC相关资讯</h1><p><a href="https://blocksandfiles.com/">Blocks and Files</a>: 存储相关，涵盖存储介质、从驱动器到阵列的设备再到基于服务器的存储、云存储等  </p>]]></content>
      
      
      
        <tags>
            
            <tag> 摸鱼 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo+Github搭建</title>
      <link href="/post/d4de41bd.html"/>
      <url>/post/d4de41bd.html</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h1><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>使用如下指令安装node.js(针对mac)：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install node</span><br></pre></td></tr></table></figure><p>安装后使用如下命令检查是否安装成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line"><span class="comment"># v18.12.1</span></span><br><span class="line"><span class="comment"># 检查npm是否安装成功,npm是node.js的包管理工具</span></span><br><span class="line">npm -v</span><br><span class="line"><span class="comment"># 9.2.0</span></span><br></pre></td></tr></table></figure><h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>配置客户端SSH key到Github，如果已经配置过可以选择忽略：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;username&quot;</span> <span class="comment"># 用户名</span></span><br><span class="line">git config --global user.email <span class="string">&quot;email@gmail.com&quot;</span> <span class="comment"># github登录邮箱</span></span><br></pre></td></tr></table></figure><p>通过终端命令生成SSH key：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;email@gmail.com&quot;</span></span><br></pre></td></tr></table></figure><p>如果已经配置过，会显示是否overwrite,选择n即可；否则会要求输入密码，然后一路回车即可，执行完成后会在~&#x2F;.ssh&#x2F;id_rsa.pub目录下生成需要使用的key（这里的文件可能会有一些变化，不过会有提示的，按照提示操作即可）。使用命令行查看 SSH key的内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>然后在Github Settings里面配置一下SSH key即可<br>测试是否与Github连接成功：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p><img src="/../img/github_connection.jpg">   </p><p>出现上图结果，即表示连接成功，上面红色框出的部分是username.</p><h2 id="本地博客关联到Github主页"><a href="#本地博客关联到Github主页" class="headerlink" title="本地博客关联到Github主页"></a>本地博客关联到Github主页</h2><p>登录Github并创建名为username.github.io的仓库，注意名字一定要正确！在Github上创建的时候如果之前创建过，会有提示红色，后面的访问权限选public；需要在本地下载hexo的git管理工具，切换回Blog目录，并输入以下指令：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cnpm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后修改Blog&#x2F;_config.yml的deploy部分：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: master <span class="comment"># github现在default branch是main，这里这样写的话会提交到branch master，github.io显示的是main分支生的，所以后续还要合并</span></span><br></pre></td></tr></table></figure><h2 id="使用cnpm安装hexo"><a href="#使用cnpm安装hexo" class="headerlink" title="使用cnpm安装hexo"></a>使用cnpm安装hexo</h2><p>cnpm版本查看，以及一些工具的安装路径显示：<br><img src="/../img/cnpm_location.jpg"><br>cnpm是中国版的npm，是淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的npm，国内用比较好</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cnpm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装不了也可以选择源代码安装，参考：<a href="https://danteng.org/how-to-install-hexo-manually/">hexo手动安装</a> </p><p>安装完成后在自选路径创建Blog(customized)文件夹，在该文件夹下初始博客：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>出现以下情况，虽然显示依赖安装失败，但其实并不影响博客初始化：<br><img src="/../img/dependencies.jpg"><br>根据它的建议是使用npm install处理此问题,如果直接使用npm可能会出现权限问题，可以使用如下指令修改用户权限：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">chown</span> -R [owner]:[owner]  /usr/local/lib/node_modules</span><br><span class="line">sudo <span class="built_in">chown</span> -R ownerName: /usr/local/lib/node_modules</span><br><span class="line">sudo <span class="built_in">chown</span> -R <span class="variable">$USER</span> /usr/local/lib/node_modules</span><br></pre></td></tr></table></figure><p>也可以直接使用sudo，但是不推荐：<br><img src="/../img/sudo.jpg"><br>依赖安装失败可参考博客：<a href="https://blog.51cto.com/u_15127596/4372091https://blog.csdn.net/weixin_44237337/article/details/119994618">关于hexo init过程中出现fail to install dependencies的解决</a></p><blockquote><p>cnpm可以解决npm的所有问题，所以还是用cnpm替吧  </p></blockquote><p>使用hexo init初始化成功之后，在blog目录下执行预览操作：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 需要hexo server的支持</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><p>会看到如下输出内容：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INFO  Validating config</span><br><span class="line">INFO  Start processing</span><br><span class="line">INFO  Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. </span><br></pre></td></tr></table></figure><p>点击上面的连接，就可以在本地访问，hexo生成的默认静态网站。命令行执行如下指令，生成博客文件并将其推送至github：</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 生成想要的博客文件</span></span><br><span class="line">hexo g</span><br><span class="line"><span class="comment"># 将本地博客文件push到github</span></span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>执行成功后，在浏览器中输入[https:&#x2F;&#x2F;]username.github.io即可对自己的Blog进行访问。如果这里本地静态博客和Github Pages不同步，可以考虑以下几点：</p><ol><li>首先确认Blog&#x2F;_config.yml配置文件中的deploy配置的是否正确</li><li>现在的Github主分支命名为main,老版本是master，看一下是否是default版本的问题</li><li>提交仓库的根地址是否正确</li></ol><h1 id="Butterfly美化"><a href="#Butterfly美化" class="headerlink" title="Butterfly美化"></a>Butterfly美化</h1><p>Butterfly主题添加到themes文件下，这个步骤网上搜就好<br>Butterfly美化主要参考：<br>【1】<a href="https://blo[g.csdn.net/qq_43740362/article/details/113783074">Butterfly美化</a><br>【2】<a href="https://chenwenjia1991.github.io/2018/11/01/GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">Hexo Butterfly配置</a><br>【3】<a href="https://hexo.io/zh-cn/docs/writing.html?spm=a2c6h.12873639.article-detail.12.3a9b8c56TI5iuH">hexo中文文档</a><br>【4】<a href="https://cloud.tencent.com/developer/article/1577027">超级详细的Hexo DIY方法</a></p><p>一些小问题，对subtitle修改后可能出现标题和副标题向左对齐，在source&#x2F;css&#x2F;_layout&#x2F;head.sty里面修改title和sub-title下面加上text-align: center即可；背景图片设置：都是在butterfly下面的_config.yml里面进行设置<br>其他page页的顶部图可以在各自的md页面设置。</p><h1 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h1><p>安装一个编写md文件的工具，个人使用vscode；  </p><p>cd到博客目录下执行hexo new  “postName” 创建文章<br>博客目录下的source&#x2F;_posts找到创建的文章，打开直接编写即可，就是正常编写markdown文件，markdown编辑参考：<a href="https://www.runoob.com/markdown/">菜鸟教程</a></p><h1 id="发布博客"><a href="#发布博客" class="headerlink" title="发布博客"></a>发布博客</h1><ol><li>本地写好博客</li><li>打开终端，cd到博客目录，执行hexo clean清空缓存</li><li>执行hexo g构建文章页面</li><li>执行hexo s本地预览整个站点</li><li>执行hexo d发布Pages更新线上博客</li></ol><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><ol><li>移动端优化还没做</li><li>搜索引擎优化没做，搜索功能存在缺陷</li><li>访问速度优化</li></ol><h2 id="博客搭建思考"><a href="#博客搭建思考" class="headerlink" title="博客搭建思考"></a>博客搭建思考</h2><p>使用Github Pages的好处：<br> 1.免费，Github提供无限流量<br> 2. 都是静态文件，世界各地都有理想的访问速度（访问速度可进一步优化）<br> 3. 拥有绝对的管理权，又享受Git的版本管理功能，不用担心文章遗失</p><p>他人的思考：<a href="https://chenwenjia1991.github.io/2018/11/01/GitHub-Pages-Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/">博客搭建思考</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 环境配置和搭建 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
